angle = atan(eigenvectors[1,1]/eigenvectors[2,1])
stretch = sqrt(eigenvalues[1])
angles = c(angles, angle)
stretchs = c(stretchs, stretch)
}
h0 = seq(0.1,5,0.1)
h1 = seq(0.1,5,0.1)
h = expand.grid(x=h0,y=h1)
angles = c()
stretchs = c()
for (i in 1:dim(h)[1]){
h0 = h[i,1]
h1 = h[i,2]
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
angle = atan(eigenvectors[1,1]/eigenvectors[2,1])
stretch = sqrt(eigenvalues[1])
angles = c(angles, angle)
stretchs = c(stretchs, stretch)
}
plotDF = data.frame(h0=h[,1],
h1=h[,2],
stretch=stretchs,
angle=angles)
ggplot(plotDF)+
geom_point(aes(x=h0,y=h1,colour=stretch))+
scale_colour_viridis()
plot(h[,1], stretchs)
plot(h[,1], angles)
plot(h[,2], angles)
ggplot(plotDF)+
geom_point(aes(x=h0,y=angles,colour=h1))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h1,y=angles,colour=h0))+
scale_colour_viridis()
plotDF = data.frame(h0=h[,1],
h1=h[,2],
stretch=stretchs,
angle=rad2deg(angles))
ggplot(plotDF)+
geom_point(aes(x=h1,y=angles,colour=h0))+
scale_colour_viridis()
angles
rad2deg(0.2)
ggplot(plotDF)+
geom_point(aes(x=h1,y=angle,colour=h0))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h0,y=stretch,colour=h1))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h1,y=stretch,colour=h0))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h0,y=stretch,colour=h1))+
scale_colour_viridis()
log(0)
log(2)
log(-1)
log(0.1)
parameters = list(X          = matrix(0.5, nrow=B, ncol=E),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7,
logh       = c(1,1))
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeAnisoCSZ.cpp",
framework="TMBad")
dyn.load(dynlib("MultiQuakeAnisoCSZ"))
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
#map     = list(thetaS=as.factor(NA)), # fixed the angle of anisotropy
random  = "X",
DLL     = "MultiQuakeAnisoCSZ",
hessian = TRUE)
# A wrapper function to see the parameters after each iteration
allPar <<- matrix(nrow=0, ncol=length(obj$par))
fnWrapper = function(par) {
# holds the parameters
allPar <<- rbind(allPar, par)
print(par)
return(obj$fn(par))
}
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = fnWrapper,
gradient  = obj$gr,
control   = list(iter.max  = 100000,
eval.max  = 100000)))[3]
opt0
parameters = list(X          = matrix(0.5, nrow=B, ncol=E),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7,
logh       = c(0.1,0.1))
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeAnisoCSZ.cpp",
framework="TMBad")
dyn.load(dynlib("MultiQuakeAnisoCSZ"))
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
#map     = list(thetaS=as.factor(NA)), # fixed the angle of anisotropy
random  = "X",
DLL     = "MultiQuakeAnisoCSZ",
hessian = TRUE)
# A wrapper function to see the parameters after each iteration
allPar <<- matrix(nrow=0, ncol=length(obj$par))
fnWrapper = function(par) {
# holds the parameters
allPar <<- rbind(allPar, par)
print(par)
return(obj$fn(par))
}
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = fnWrapper,
gradient  = obj$gr,
control   = list(iter.max  = 100000,
eval.max  = 100000)))[3]
opt0
print(optTime)
h0 = exp(opt0$par[5])
h1 = exp(opt0$par[6])
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
eigenvalues
eigenvectors
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
log(0.9)
parameters = list(X          = matrix(0.5, nrow=B, ncol=E),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7,
logh       = c(0,-0.1))
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeAnisoCSZ.cpp",
framework="TMBad")
dyn.load(dynlib("MultiQuakeAnisoCSZ"))
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
#map     = list(thetaS=as.factor(NA)), # fixed the angle of anisotropy
random  = "X",
DLL     = "MultiQuakeAnisoCSZ",
hessian = TRUE)
# A wrapper function to see the parameters after each iteration
allPar <<- matrix(nrow=0, ncol=length(obj$par))
fnWrapper = function(par) {
# holds the parameters
allPar <<- rbind(allPar, par)
print(par)
return(obj$fn(par))
}
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = fnWrapper,
gradient  = obj$gr,
control   = list(iter.max  = 100000,
eval.max  = 100000)))[3]
# ## Optimize the model parameters with optim
# optTime = system.time(opt0 <- optim(par     = obj$par,
#                                     fn      = obj$fn,
#                                     gadient = obj$gr))[3]
print(opt0)
print(optTime)
h0 = 0.9
h1 = 1
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
h0 = 1
h1 = 1
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
opt0
exp(-1.15)
h0 = 0.5
h1 = 0.3
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
print(atan(eigenvectors[1,1]/eigenvectors[2,1]))
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
h0 = 0.5
h1 = 0.4
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
h0 = 0.5
h1 = 0.5
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
log(0.5)
parameters = list(X          = matrix(0.5, nrow=B, ncol=E),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7,
logh       = c(-0.6931472,-0.6931472))
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeAnisoCSZ.cpp",
framework="TMBad")
dyn.load(dynlib("MultiQuakeAnisoCSZ"))
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
#map     = list(thetaS=as.factor(NA)), # fixed the angle of anisotropy
random  = "X",
DLL     = "MultiQuakeAnisoCSZ",
hessian = TRUE)
# A wrapper function to see the parameters after each iteration
allPar <<- matrix(nrow=0, ncol=length(obj$par))
fnWrapper = function(par) {
# holds the parameters
allPar <<- rbind(allPar, par)
print(par)
return(obj$fn(par))
}
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = fnWrapper,
gradient  = obj$gr,
control   = list(iter.max  = 100000,
eval.max  = 100000)))[3]
# ## Optimize the model parameters with optim
# optTime = system.time(opt0 <- optim(par     = obj$par,
#                                     fn      = obj$fn,
#                                     gadient = obj$gr))[3]
print(opt0)
print(optTime)
h0 = exp(opt0$par[5])
h1 = exp(opt0$par[6])
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(eigenvalues)
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
h0 = seq(0.01,2,0.01)
h1 = seq(0.01,2,0.01)
h = expand.grid(x=h0,y=h1)
test = 0
for (i in 1:dim(h)[1]){
h0 = h[i,1]
h1 = h[i,2]
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
test = test + sum(eigenvectors[,1]*eigenvectors[,2])
}
test
test = 0
for (i in 1:dim(h)[1]){
h0 = h[i,1]
h1 = h[i,2]
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(sum(eigenvectors[,1]*eigenvectors[,2]))
}
?eigen
h0 = 0.5
h1 = 0.1
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
eigenvalues
h0 = 0.1
h1 = 0.5
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
eigenvectors
opt0
h0 = exp(2.2533571)
h1 = exp(-0.9585189)
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
h0
h1
h0 = 0.5
h1 = 0.5
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
print(sqrt(eigenvalues))
# plot ellipse
major_length <- sqrt(eigenvalues[1])
minor_length <- sqrt(eigenvalues[2])
major_direction <- eigenvectors[,1]
minor_direction <- eigenvectors[,2]
angles <- seq(0, 2*pi, length.out = 100)
x <- major_length * cos(angles) * major_direction[1] + minor_length * sin(angles) * minor_direction[1]
y <- major_length * cos(angles) * major_direction[2] + minor_length * sin(angles) * minor_direction[2]
plot(x, y, type = "l", asp = 1, xlab = "X", ylab = "Y", main = "Coviance Structure")
h0 = seq(0.01,10,0.1)
h1 = seq(0.01,10,0.1)
h = expand.grid(x=h0,y=h1)
angles = c()
stretchs = c()
for (i in 1:dim(h)[1]){
h0 = h[i,1]
h1 = h[i,2]
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
angles = c(angles, rad2deg(atan(eigenvectors[1,1]/eigenvectors[2,1])))
stretchs = c(stretchs, sqrt(eigenvalues))
}
plotDF = data.frame(h0=h[,1],
h1=h[,2],
stretch=stretchs,
angle=angles)
ggplot(plotDF)+
geom_point(aes(x=h1,y=angle,colour=h0))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h0,y=stretch,colour=h1))+
scale_colour_viridis()
ggplot(plotDF)+
geom_point(aes(x=h0,y=angle,colour=h1))+
scale_colour_viridis()
plot(stretchs)
plotangles
plot(angles)
opt0
exp92.2533571
exp(2.2533571)
exp(-0.9585189)
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
H
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(eigenvalues)
h0 = exp(opt0$par[5])
h1 = exp(opt0$par[6])
H = matrix(c(h0,      log(h1),
log(h1), (1+log(h1)^2)/h0),
nrow=2)
# Compute eigenvalues and eigenvectors
eigen_result = eigen(H)
eigenvalues = eigen_result$values
eigenvectors = eigen_result$vectors
print(eigenvalues)
