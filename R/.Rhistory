install.packages('class')
install.packages('class')
install.packages('caret')
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
install.packages(ggplot2)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/TestModels.R", echo=TRUE)
2+2
print('hello')
x <- 5
x
x + 3
x**2
x/2
clear(x)
print("hello world")
print("hello world")
source("~/Uni/NTNU/Time Series/Exercise2.R", echo=TRUE)
source("~/Uni/NTNU/Time Series/Exercise2.R", echo=TRUE)
source("~/Uni/NTNU/Time Series/Exercise2.R")
plot(x,s)
source("~/.active-rstudio-document", echo=TRUE)
plot(x,s)+
labs(xlab="Location", s="Observation")
plot(x,s)+
title(xlab="Location", s="Observation")
plot(x,s)+
title(xlab="Location", y="Observation")
plot(x,s, xlab="Location", y="Observation")
plot(x,s, xlab="Location", ylab="Observation")
plot(x, s,
title = "Simple Kriging Example"
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example"
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example",
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
plot(s, x,
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
plot(s, x,
xlim=c(0,10), ylim=c(-3,3),
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
dyn.load?
load("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence/DR1.RData")
View(dr1)
View(dr1)
1.5/2.2
(1.5/2.2) * 0.005
(1.7/2.8)*0.0036
40.86 - 0.002185714
124.108 + (1.6/2.2)*0.005
124.108 - (1.7/2.2)*0.005
124.108 - (1.5/2.2)*0.005
124.108 + (1.5/2.2)*0.005
124.108 - (1.7/2.2)*0.005
40.86 + (0.1/2.8)*0.0036
124.103 - (0.7/6.8)*0.005
40.86 + (0.7/6.3)*0.0036
View(dr1)
View(dr1)
print(colnames(dr1))
Region = rep("California", 3)
Site = rep("Humboldt Bay", 3)
Lat = c(40.858, 40.860, 40.860)
Lon = c(-124.111, -124.104, -124.103)
event = c("T1", "T3", "T5")
subsidence = c(0.85, 0.42, 0.79)
Uncertainty = c(0.46, 0.37, 0.47)
source = rep(49, 3)
quality = rep(1, 3)
cbind((Region, Site, Lon, Lat))
cbind(Region, Site)
dr2 = data.frame(cbind(Region, Site,
Lat, Lon,
event,
subsidence, Uncertainty,
source, quality))
View(dr2)
dr3 = rbind(dr1, dr2, fill=TRUE)
dr3 = data.frame(rbind(data.table(dr1), data.table(dr2), fill=TRUE))
table(dr1)
dr3 = rbind(dr1, dr2, fill=TRUE)
library(dplyr)
dr3 = bind_rows(dr1, dr2)
Lat = as.double(c(40.858, 40.860, 40.860))
Lon = as.double(c(-124.111, -124.104, -124.103))
dr2 = data.frame(cbind(Region, Site,
Lat, Lon,
event,
subsidence, Uncertainty,
source, quality))
dr3 = bind_rows(dr1, dr2)
dr2
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/Setup.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/plotter.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/resultsHandling.R", echo=TRUE)
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# Add the negative log likelihood functions from the TMB code
compile("BayesianCSZ.cpp")
dyn.load(dynlib("BayesianCSZ"))
# Which earthquake the model is run for
# Levels: T1 T10 T10R1 T11 T12 T2 T3 T3a T4 T4a T5
#         T5a T5b T6 T6a T7 T7a T8 T8a T9 T9a
# T1 == 1700 earthquake
earthquake = "T1"
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR3.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFullFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as "mediumFault"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the okada matrix
# If not created use the "getokada" function with the current fault data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load(paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMesh.RData") # loads in two spde objects
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
## get the observed subsidence data for the correct earthquake
# Note change sign to minus since Okada model gives negative values for downwards movements.
subsidence = -DR3$subsidence[DR3$event == earthquake]
# get the variance in data
V = DR3$Uncertainty[DR3$event == earthquake]
N = length(subsidence) # number of data points
K = length(simpleFault) # number of subfaults
M = dim(inla_mesh$loc)[1] # number of points in spde mesh
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -simpleFault[[i]]$depth / (10^3) # change to kms
}
## SPDE part:
# Create the spde object with correct priors
# PC priors on SPDE
# P(range < a) = b
# P(sigma > c) = d
a = 150 # Estimated range of the spatial field
b = 0.5
c = 1 # an ``upper bound'' on the variance
d = 0.10
maternPri = c(a, b, c, d)
# create spde object
inla_spde = inla.spde2.pcmatern(inla_mesh,
alpha=2,
prior.range=c(a, b),
prior.sigma=c(c, d))
# get the matricies out
spdeMatrix = inla_spde$param.inla[c("M0","M1","M2")]
# shape found from taperPrior.R
# means that 95% of the time the taper drops to 0.05 by 20km.
shape = 1.413327
scale = 1
taperPri = c(shape, scale)
# set up the data list
data = list(depth      = depths,
subsidence = subsidence,
V          = V,
okada      = as.matrix(G),
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
M0         = spdeMatrix$M0,
M1         = spdeMatrix$M1,
M2         = spdeMatrix$M2,
maternPri  = maternPri,
taperPri   = taperPri)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = rep(0, M),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="BayesianCSZ",
hessian=TRUE)
## Optimize the model parameters
opt0 = nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr)
# Check the state of the optimisation
# Gets important outputs from opt0 and obj.
# Plots subsidences, spatial effects, tapered and untapetred slips
checkOptimisation(obj, opt0, inla_mesh, simpleFault, DR3, earthquake)
## Get standard errors via SD report
SD0 = TMB::sdreport(obj, getJointPrecision=TRUE,
bias.correct = TRUE,
bias.correct.control = list(sd = TRUE))
# Check the joint precision is positive definite
print(is.positive.definite(as.matrix(SD0$jointPrecision)))
# Get draws from all the model parameters
nSims = 1000
draws = simulateCSZ(SD0, nSims=nSims)
## extract the draws for each parameter the draws
parnames = c(names(SD0[['par.fixed']]), names(SD0[['par.random']]))
logLambdaDraws  = draws[parnames == 'logLambda',]
muDraws = draws[parnames == 'mu',]
logKappaDraws = draws[parnames == 'logKappa',]
logTauDraws = draws[parnames == 'logTau',]
xDraws = draws[parnames == 'x',]
## create the slip draws
slipDraws = matrix(data=0, nrow=K, ncol=nSims)
## loop and do all simulations for each subfault
for (i in 1:K){
taper = exp(-exp(logLambdaDraws) * depths[i]) # 1000 sims og the kth fault
idx = inla_mesh$idx$loc[i] # correct x index
slipDraws[i,] = taper * exp(muDraws + xDraws[idx,]) # 1000 slips
}
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
# Now I find the magnitude of all the simulated slips
magnitudes = rep(0, nSims)
for (i in 1:nSims){
magnitudes[i] = getMomentFromSlip(slips = slipDraws[,i],
fault = simpleFault)
}
# Plot the resulting magnitudes as a histogram
g10 = summariseMagnitudes(magnitudes)
plot(g10)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
for (i in 1:nSims){
magnitudes[i] = getMomentFromSlip(slips = slipDraws[,i],
fault = simpleFault)
}
# Plot the resulting magnitudes as a histogram
g10 = summariseMagnitudes(magnitudes)
plot(g10)
SD0
which(magnitudes < 1)
badSlip = slipDraws[,234]
testg = plotFault(simpleFault, z=badSlip, legenTitle="Slip (m)")
testg = plotFault(simpleFault, z=badSlip, legendTitle="Slip (m)")
testg
taperDraws = exp(-exp(logLambdaDraws[234])*depths)
length(taperDraws)
K
testg2 = plotFault(simpleFault, z=taperDraws, legendTitle="Taper")
testg2
logLambdaDraws[234]
mean(logLambdaDraws)
exp(logLambdaDraws[234])
# Assume λ ~ Gamma(k, theta)
# The function we actually want the roots of
f = function(x){
k = x[1]
theta = x[2]
Q2 = qgamma(.025, shape=k, scale=theta)
Q1 = qgamma(.975, shape=k, scale=theta)
lowerVal = -log(.05)/30
upperVal = -log(.05)/20
loss = (Q2 - lowerVal)^2 + (Q1 - upperVal)^2
#f1 = (1 - pgamma(lowerCV, shape=k, scale=theta)) - ((1-alpha)/2)
#f2 = pgamma(upperCV, shape=k, scale=theta) - (alpha + (1-alpha)/2)
return(loss)
}
testPrior = optim(c(1,1), f)
testPrior
testPrior = optim(c(1,1), f, method="Nelder-Mead")
testPrior
# Assume λ ~ Gamma(k, theta)
# The function we actually want the roots of
f = function(x){
k = x[1]
theta = x[2]
Q2 = qgamma(.025, shape=k, scale=theta)
Q1 = qgamma(.975, shape=k, scale=theta)
lowerVal = -log(.05)/30
upperVal = -log(.05)/20
loss = (Q2 - lowerVal)^2 + (Q1 - upperVal)^2
#f1 = (1 - pgamma(lowerCV, shape=k, scale=theta)) - ((1-alpha)/2)
#f2 = pgamma(upperCV, shape=k, scale=theta) - (alpha + (1-alpha)/2)
#return(loss)
f1 = Q2 - lowerVal
f2 = Q1 - upperVal
return(c(f1, f2))
}
# The find the root so that the shape which satisfies (1) is found
# This doesn't work currently
testRoot = multiroot(f, start=c(1,1), maxiter=10000, positive=TRUE)
testRoot
# Assume λ ~ Gamma(k, theta)
# The function we actually want the roots of
f = function(x){
k = x[1]
theta = x[2]
Q2 = qgamma(.025, shape=k, scale=theta)
Q1 = qgamma(.975, shape=k, scale=theta)
lowerVal = -log(.05)/30
upperVal = -log(.05)/20
loss = (Q2 - lowerVal)^2 + (Q1 - upperVal)^2
#f1 = (1 - pgamma(lowerCV, shape=k, scale=theta)) - ((1-alpha)/2)
#f2 = pgamma(upperCV, shape=k, scale=theta) - (alpha + (1-alpha)/2)
return(loss)
#f1 = Q2 - lowerVal
#f2 = Q1 - upperVal
#return(c(f1, f2))
}
testPrior = optim(c(1,1), f, method="Nelder-Mead")
testPrior
# shape found from taperPrior.R
shape = 93.757027137
scale = 0.001316695
taperPri = c(shape, scale)
# set up the data list
data = list(depth      = depths,
subsidence = subsidence,
V          = V,
okada      = as.matrix(G),
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
M0         = spdeMatrix$M0,
M1         = spdeMatrix$M1,
M2         = spdeMatrix$M2,
maternPri  = maternPri,
taperPri   = taperPri)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = rep(0, M),
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="BayesianCSZ",
hessian=TRUE)
## Optimize the model parameters
opt0 = nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr)
## Get standard errors via SD report
SD0 = TMB::sdreport(obj, getJointPrecision=TRUE,
bias.correct = TRUE,
bias.correct.control = list(sd = TRUE))
# summarise the SD report
summary(SD0, "report")
SD0
# Get draws from all the model parameters
nSims = 1000
draws = simulateCSZ(SD0, nSims=nSims)
## extract the draws for each parameter the draws
parnames = c(names(SD0[['par.fixed']]), names(SD0[['par.random']]))
logLambdaDraws  = draws[parnames == 'logLambda',]
muDraws = draws[parnames == 'mu',]
logKappaDraws = draws[parnames == 'logKappa',]
logTauDraws = draws[parnames == 'logTau',]
xDraws = draws[parnames == 'x',]
## create the slip draws
slipDraws = matrix(data=0, nrow=K, ncol=nSims)
## loop and do all simulations for each subfault
for (i in 1:K){
taper = exp(-exp(logLambdaDraws) * depths[i]) # 1000 sims og the kth fault
idx = inla_mesh$idx$loc[i] # correct x index
slipDraws[i,] = taper * exp(muDraws + xDraws[idx,]) # 1000 slips
}
# Now I find the magnitude of all the simulated slips
magnitudes = rep(0, nSims)
for (i in 1:nSims){
magnitudes[i] = getMomentFromSlip(slips = slipDraws[,i],
fault = simpleFault)
}
# Plot the resulting magnitudes as a histogram
g10 = summariseMagnitudes(magnitudes)
plot(g10)
