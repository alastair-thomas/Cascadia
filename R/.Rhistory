event,
subsidence, Uncertainty,
source, quality))
View(dr2)
dr3 = rbind(dr1, dr2, fill=TRUE)
dr3 = data.frame(rbind(data.table(dr1), data.table(dr2), fill=TRUE))
table(dr1)
dr3 = rbind(dr1, dr2, fill=TRUE)
library(dplyr)
dr3 = bind_rows(dr1, dr2)
Lat = as.double(c(40.858, 40.860, 40.860))
Lon = as.double(c(-124.111, -124.104, -124.103))
dr2 = data.frame(cbind(Region, Site,
Lat, Lon,
event,
subsidence, Uncertainty,
source, quality))
dr3 = bind_rows(dr1, dr2)
dr2
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# Add the negative log likelihood  functionsfrom the C++ code
compile("FrequentistCSZ.cpp")
dyn.load(dynlib("FrequentistCSZ"))
# Which earthquake the model is run for
# Levels: T1 T10 T10R1 T11 T12 T2 T3 T3a T4 T4a T5
#         T5a T5b T6 T6a T7 T7a T8 T8a T9 T9a
# T1 == 1700 earthquake
earthquake = "T1"
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR3.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as "mediumFault"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the okada matrix
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrix", earthquake, ".RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load(paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G = getOkada(geom = simpleFault,
lon  = DR3$Lon[DR3$event == earthquake],
lat  = DR3$Lat[DR3$event == earthquake],
earthquake = earthquake)
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
save(G, file=paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
}
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMesh.RData") # loads in two spde objects
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
## get the observed subsidence data for the correct earthquake
# Note change sign to minus since Okada model gives negative values for downwards movements.
subsidence = -DR3$subsidence[DR3$event == earthquake]
# I assume that these are the sigma values to be used?
V = DR3$Uncertainty[DR3$event == earthquake]
N = length(subsidence) # number of data points
K = length(simpleFault) # number of subfaults
M = dim(inla_mesh$loc)[1] # number of points in spde mesh
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -simpleFault[[i]]$depth / (10^3) # change to kms
}
## SPDE part:
# Get the spde matrices
spdeMatrix = inla_spde$param.inla[c("M0","M1","M2")] # builds 3 components of Q (precision matrix)
# set up the data list
data = list(depth      = depths,
subsidence = subsidence,
V          = V,
okada      = as.matrix(G),
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
spde       = spdeMatrix)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = rep(0, M),
log_lambda = -2.1,
mu         = 3.6,
log_kappa  = -4.6,
log_tau2   = 3.8)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="CSZmodel1",
hessian=TRUE)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="FrequentistCSZ",
hessian=TRUE)
## it seems like nlminb works well!
opt0 = nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr)
print(tail(obj$env$last.par))
print(tail(obj$env$last.par.best))
print(opt0)
if (all(tail(obj$env$last.par, 4) == opt0$par)){
thispar = obj$env$last.par
print("Last parameters")
} else if (all(tail(obj$env$last.par.best, 4) == opt0$par)){
thispar = obj$env$last.par.best
print("Not last parameters")
} else{
stop("Parameters aren't last params")
}
r = obj$report(thispar)
effRange = sqrt(8*1)/exp(opt0$par[3])
print(paste("Effective Range: ", round(effRange, 2), "Km"))
# check predicted subsidences
lats  = DR3$Lat[DR3$event == earthquake]
xlim = range(c(r$okadaSubsidence, -DR3$subsidence[DR3$event == earthquake]))
plot(r$okadaSubsidence, lats, xlim=xlim, pch=19, col='blue', cex=.2)
points(-DR3$subsidence[DR3$event == earthquake], lats, pch=19, col='black', cex=.2)
# Check the plot of the spatial field
g = plotX(inla_mesh, z=r$x)
plot(g)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/plotter.R", echo=TRUE)
# Check the plot of the spatial field
g = plotX(inla_mesh, z=r$x)
plot(g)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
# Check the plot of the spatial field
g = plotX(inla_mesh, z=r$x)
plot(g)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/Setup.R", echo=TRUE)
# Check the plot of the spatial field
g = plotX(inla_mesh, z=r$x)
plot(g)
# check average untapered slip
g2 = plotFault(simpleFault, z=r$untaperedSlips, legendTitle="Untapered Slips (m)")
plot(g2)
# plot tapered slips
g3 = plotFault(simpleFault, z=r$taperedSlips, legendTitle="Tapered Slips (m)")
plot(g3)
## Get standard errors
SD0 = TMB::sdreport(obj, getJointPrecision=TRUE,
bias.correct = TRUE,
bias.correct.control = list(sd = TRUE))
summary(SD0, "report")
# here I should check that I get a PD covariance structure
print(is.positive.definite(as.matrix(SD0$jointPrecision)))
# simulate draws
rmvnorm_prec = function(mu, chol_prec, nSims) {
z = matrix(rnorm(length(mu) * nSims), ncol=nSims)
L = chol_prec #Cholesky(prec, super=TRUE)
z = Matrix::solve(L, z, system = "Lt") ## z = Lt^-1 %*% z
z = Matrix::solve(L, z, system = "Pt") ## z = Pt    %*% z
z = as.matrix(z)
mu + z
}
# take samples from fitted model
mu = c(SD0$par.fixed, SD0$par.random)
nSims = 1000
L = Cholesky(SD0[['jointPrecision']], super = T)
draws = rmvnorm_prec(mu = mu ,
chol_prec = L,
nSims = nSims)
## summarize the draws
parnames = c(names(SD0[['par.fixed']]), names(SD0[['par.random']]))
logLambdaDraws  = draws[parnames == 'log_lambda',]
muDraws = draws[parnames == 'mu',]
logKappaDraws = draws[parnames == 'log_kappa',]
logTauDraws = draws[parnames == 'log_tau2',]
xDraws = draws[parnames == 'x',]
draws = data.frame(logLambda = logLambdaDraws,
Mu = muDraws,
logKappa = logKappaDraws,
logTau = logTauDraws)
drawsLong = as.data.frame(pivot_longer(draws,
cols = everything(),
names_to = "Parameter",
values_to = "Value"))
# Create a 2x2 grid of histograms
# cairo_pdf used so that the greek symbols are saved nicely
g4 = ggplot(drawsLong, aes(x = Value, fill=Parameter)) +
geom_histogram(bins=30, position = "identity", alpha = 0.8) +
facet_wrap(~Parameter,
scales = "free",
labeller = as_labeller(c('logKappa'='log(\u03ba)',
'logLambda'='log(\u03bb)',
'logTau'='log(\u03c4)',
'Mu'='\u03bc'))) +
guides(fill = "none") +
xlab("Parameter Value") +
ylab("Count")
plot(g4)
parSum = cbind(mean=(apply(draws, 2, mean)),
median = (apply(draws, 2, median)),
sd     = (apply(draws, 2, sd)),
lower = (apply(draws, 2, quantile, .05)),
upper = (apply(draws, 2, quantile, .95)))
print(parSum)
xSum = cbind(mean   = (apply(xDraws, 1, mean)),
median = (apply(xDraws, 1, median)),
sd     = (apply(xDraws, 1, sd)))
# plot the mean x distribution
g5 = plotX(inla_mesh, z=xSum[,1], legendTitle="Spatial Random Effect\nMean")
plot(g5)
# plot the standard deviation of x distribution
g6 = plotX(inla_mesh, z=xSum[,3], legendTitle="Spatial Random Effect\nStandard Deviation", colourScale="plasma")
plot(g6)
## create the slip draws
slipDraws = matrix(data=0, nrow=K, ncol=nSims)
# testing x distribution
idx = inla_mesh$idx$loc[4]
hist(xDraws[idx,])
## loop and do all simulations for each subfault
for (i in 1:K){
taper = exp(-exp(logLambdaDraws) * depths[i]) # 1000 sims og the kth fault
idx = inla_mesh$idx$loc[i] # correct x index
slipDraws[i,] = taper * exp(muDraws + xDraws[idx,]) # 1000 slips
}
## find the median and sd across draws, as well as 90% intervals
slipSum = cbind(mean = (apply(slipDraws, 1, mean)),
median = (apply(slipDraws, 1, median)),
sd     = (apply(slipDraws, 1, sd)),
lower = (apply(slipDraws, 1, quantile, .05)),
upper = (apply(slipDraws, 1, quantile, .95)))
# plot the posterior mean slip
g7 = plotFault(simpleFault, z=slipSum[,1], legendTitle="Posterior Slip\nMean (m)")
plot(g7)
# plot the posterior median slip
g8 = plotFault(simpleFault, z=slipSum[,2], legendTitle="Posterior Slip\nMedian (m)")
plot(g8)
# plot the posterior slip standard deviation
g9 = plotFault(simpleFault,
z=slipSum[,3],
legendTitle="Posterior Slip\nStandard Deviation (m)",
colourScale="plasma")
plot(g9)
# now calculate subsidences for each data point
# I use the mean slip across each sub fault
subPred = G3 %*% slipSum[,1]
absError = abs(subsidence - subPred)
signError = sign(subsidence) == sign(subPred)
g10 = plotErrors(absError, signError)
# now calculate subsidences for each data point
# I use the mean slip across each sub fault
subPred = G %*% slipSum[,1]
absError = abs(subsidence - subPred)
signError = sign(subsidence) == sign(subPred)
g10 = plotErrors(absError, signError)
plot(g10)
print(paste("Count of wrong sign: ", N - sum(signError)))
gridN = 25
lon = seq(-128, -123, length.out=gridN)
lat = seq(40, 50, length.out=gridN)
lonLat = expand.grid(x=lon, y=lat)
# load in the okada matrix for the whole fault
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrixT1Whole.RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load("OkadaMatrixT1Whole.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G4 = getOkada(geom = mediumFault,
lon  = lonLat$x,
lat  = lonLat$y,
earthquake = "T1Whole")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
save(G4, file="OkadaMatrixMediumT1Whole.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
}
# predict subsidence
subWholeFault = G2 %*% slipSum[,1]
dim(G)
# load in the okada matrix for the whole fault
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrixT1Whole.RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load("OkadaMatrixT1Whole.RData")
G2 = G
load("OkadaMatrixT1.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G4 = getOkada(geom = mediumFault,
lon  = lonLat$x,
lat  = lonLat$y,
earthquake = "T1Whole")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
save(G4, file="OkadaMatrixMediumT1Whole.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
}
# predict subsidence
subWholeFault = G2 %*% slipSum[,1]
# set up for plotting
subDF = data.frame(Lon=lonLat$x,
Lat=lonLat$y,
Sub=subWholeFault)
# here I use the Scico package which has diverging colour scales
# that are also safe to use for blind people.
g11 = plotBase(labels=FALSE, countryBoundary=FALSE)
g11 = g11 +
geom_tile(data=subDF, aes(x=Lon, y=Lat, fill=Sub)) +
scale_fill_scico(alpha=0.75, palette = 'vik', midpoint=0, name="Subsidence (m)") +
#scale_fill_viridis_c(alpha=0.75, name="Subsidence (m)", option="viridis") +
theme(legend.position = "right", legend.key.height = unit(3, 'cm')) +
coord_sf(xlim=-c(128, 122), ylim=c(40, 50))
plot(g11)
subsidenceDraws = matrix(0, nrow=gridN^2, ncol=nSims)
for (i in 1:nSims){
subsidenceDraws[,i] = G4 %*% slipDraws[,i]
}
subsidenceDraws = matrix(0, nrow=gridN^2, ncol=nSims)
for (i in 1:nSims){
subsidenceDraws[,i] = G2 %*% slipDraws[,i]
}
subsidenceSum = cbind(mean = (apply(subsidenceDraws, 1, mean)),
median = (apply(subsidenceDraws, 1, median)),
sd     = (apply(subsidenceDraws, 1, sd)),
lower = (apply(subsidenceDraws, 1, quantile, .05)),
upper = (apply(subsidenceDraws, 1, quantile, .95)))
subDF = cbind(subDF, subsidenceSum)
g12 = plotBase(labels=FALSE, countryBoundary=FALSE)
g12 = g12 +
geom_tile(data=subDF, aes(x=Lon, y=Lat, fill=sd, alpha=sd)) +
scale_fill_viridis_c(name="Subsidence\nStandard Deviation (m)",
option="plasma", direction=-1) +
theme(legend.position = "right", legend.key.height = unit(1, 'cm')) +
coord_sf(xlim=-c(128, 123), ylim=c(40, 50)) +
guides(alpha="none")
plot(g12)
rep(c(1,2,3,4), 2)
checkOptimisation = function(obj, opt0, mesh, fault, DR){
print(tail(obj$env$last.par))
print(tail(obj$env$last.par.best))
print(opt0)
if (all(tail(obj$env$last.par, 4) == opt0$par)){
thispar = obj$env$last.par
print("Last parameters")
} else if (all(tail(obj$env$last.par.best, 4) == opt0$par)){
thispar = obj$env$last.par.best
print("Not last parameters")
} else{
stop("Parameters aren't last params")
}
# get the report from the TMB object
r = obj$report(thispar)
# Find the effective range
effRange = sqrt(8*1)/exp(opt0$par[3])
print(paste("Effective Range: ", round(effRange, 2), "Km"))
# check predicted subsidences
# gets the base map of the CSZ
g = plotBase(scale=2)
N = length(DR$Site[DR$event == earthquake])
subDF = data.frame(Site = rep(DR$Site[DR$event == earthquake], 2),
Lat  = rep(DR$Lat[DR$event == earthquake], 2),
Lon  = rep(DR$Lon[DR$event == earthquake], 2),
Sub  = c(DR$Subsidence[DR$event == earthquake], r$okadaSubsidence),
Type = c(rep("Data", N), rep("Prediction", N)))
g = g +
geom_point(data=subDF, aes(x=Lon, y=Lat, colour=Sub, shape=Type), size=2) +
scale_colour_viridis_c() +
coord_sf(xlim=-c(128, 122), ylim=c(40, 50))
plot(g)
# Check the plot of the spatial field
g1 = plotX(mesh, z=r$x)
plot(g1)
# check average untapered slip
g2 = plotFault(fault, z=r$untaperedSlips, legendTitle="Untapered Slips (m)")
plot(g2)
# plot tapered slips
g3 = plotFault(fault, z=r$taperedSlips, legendTitle="Tapered Slips (m)")
plot(g3)
}
checkOptimisation(obj, opt0, inla_mesh, simpleFault, DR3)
?plotBase
checkOptimisation = function(obj, opt0, mesh, fault, DR){
print(tail(obj$env$last.par))
print(tail(obj$env$last.par.best))
print(opt0)
if (all(tail(obj$env$last.par, 4) == opt0$par)){
thispar = obj$env$last.par
print("Last parameters")
} else if (all(tail(obj$env$last.par.best, 4) == opt0$par)){
thispar = obj$env$last.par.best
print("Not last parameters")
} else{
stop("Parameters aren't last params")
}
# get the report from the TMB object
r = obj$report(thispar)
# Find the effective range
effRange = sqrt(8*1)/exp(opt0$par[3])
print(paste("Effective Range: ", round(effRange, 2), "Km"))
# check predicted subsidences
# gets the base map of the CSZ
g = plotBase(scale=2, labels=FALSE)
N = length(DR$Site[DR$event == earthquake])
subDF = data.frame(Lat  = DR$Lat[DR$event == earthquake],
Lon  = DR$Lon[DR$event == earthquake],
Error  = abs(DR$Subsidence[DR$event == earthquake] - r$okadaSubsidence))
g = g +
geom_point(data=subDF, aes(x=Lon, y=Lat, colour=Error), size=2) +
scale_colour_viridis_c(option="plasma") +
coord_sf(xlim=-c(128, 122), ylim=c(40, 50))
plot(g)
# Check the plot of the spatial field
g1 = plotX(mesh, z=r$x)
plot(g1)
# check average untapered slip
g2 = plotFault(fault, z=r$untaperedSlips, legendTitle="Untapered Slips (m)")
plot(g2)
# plot tapered slips
g3 = plotFault(fault, z=r$taperedSlips, legendTitle="Tapered Slips (m)")
plot(g3)
}
checkOptimisation(obj, opt0, inla_mesh, simpleFault, DR3)
checkOptimisation = function(obj, opt0, mesh, fault, DR, earthquake){
print(tail(obj$env$last.par))
print(tail(obj$env$last.par.best))
print(opt0)
if (all(tail(obj$env$last.par, 4) == opt0$par)){
thispar = obj$env$last.par
print("Last parameters")
} else if (all(tail(obj$env$last.par.best, 4) == opt0$par)){
thispar = obj$env$last.par.best
print("Not last parameters")
} else{
stop("Parameters aren't last params")
}
# get the report from the TMB object
r = obj$report(thispar)
# Find the effective range
effRange = sqrt(8*1)/exp(opt0$par[3])
print(paste("Effective Range: ", round(effRange, 2), "Km"))
# check predicted subsidences
# gets the base map of the CSZ
g = plotBase(scale=2, labels=FALSE)
subDF = data.frame(Lat  = DR$Lat[DR$event == earthquake],
Lon  = DR$Lon[DR$event == earthquake],
Error  = abs(DR$subsidence[DR$event == earthquake] - r$okadaSubsidence))
g = g +
geom_point(data=subDF, aes(x=Lon, y=Lat, colour=Error), size=2) +
scale_colour_viridis_c(option="plasma") +
coord_sf(xlim=-c(128, 122), ylim=c(40, 50))
plot(g)
# Check the plot of the spatial field
g1 = plotX(mesh, z=r$x)
plot(g1)
# check average untapered slip
g2 = plotFault(fault, z=r$untaperedSlips, legendTitle="Untapered Slips (m)")
plot(g2)
# plot tapered slips
g3 = plotFault(fault, z=r$taperedSlips, legendTitle="Tapered Slips (m)")
plot(g3)
}
checkOptimisation(obj, opt0, inla_mesh, simpleFault, DR3, earthquake)
checkOptimisation = function(obj, opt0, mesh, fault, DR, earthquake){
print(tail(obj$env$last.par))
print(tail(obj$env$last.par.best))
print(opt0)
if (all(tail(obj$env$last.par, 4) == opt0$par)){
thispar = obj$env$last.par
print("Last parameters")
} else if (all(tail(obj$env$last.par.best, 4) == opt0$par)){
thispar = obj$env$last.par.best
print("Not last parameters")
} else{
stop("Parameters aren't last params")
}
# get the report from the TMB object
r = obj$report(thispar)
# Find the effective range
effRange = sqrt(8*1)/exp(opt0$par[3])
print(paste("Effective Range: ", round(effRange, 2), "Km"))
# check predicted subsidences
# gets the base map of the CSZ
g = plotBase(scale=2, labels=FALSE)
subDF = data.frame(Lat  = DR$Lat[DR$event == earthquake],
Lon  = DR$Lon[DR$event == earthquake],
Error  = abs(DR$subsidence[DR$event == earthquake] - r$okadaSubsidence))
g = g +
geom_point(data=subDF, aes(x=Lon, y=Lat, colour=Error), size=2) +
scale_colour_viridis_c(name="Subsidence Predictions\nAbsolute Error", option="plasma") +
coord_sf(xlim=-c(128, 122), ylim=c(40, 50))
plot(g)
# Check the plot of the spatial field
g1 = plotX(mesh, z=r$x)
plot(g1)
# check average untapered slip
g2 = plotFault(fault, z=r$untaperedSlips, legendTitle="Untapered Slips (m)")
plot(g2)
# plot tapered slips
g3 = plotFault(fault, z=r$taperedSlips, legendTitle="Tapered Slips (m)")
plot(g3)
}
checkOptimisation(obj, opt0, inla_mesh, simpleFault, DR3, earthquake)
