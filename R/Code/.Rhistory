install.packages('class')
install.packages('class')
install.packages('caret')
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
install.packages(ggplot2)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/stylometryfunctions.R", echo=TRUE)
source("~/Uni/Year4/Statistical Case Studies/Project 2a/TestModels.R", echo=TRUE)
2+2
print('hello')
x <- 5
x
x + 3
x**2
x/2
clear(x)
print("hello world")
print("hello world")
source("~/Uni/NTNU/Time Series/Exercise2.R", echo=TRUE)
source("~/Uni/NTNU/Time Series/Exercise2.R", echo=TRUE)
source("~/Uni/NTNU/Time Series/Exercise2.R")
plot(x,s)
source("~/.active-rstudio-document", echo=TRUE)
plot(x,s)+
labs(xlab="Location", s="Observation")
plot(x,s)+
title(xlab="Location", s="Observation")
plot(x,s)+
title(xlab="Location", y="Observation")
plot(x,s, xlab="Location", y="Observation")
plot(x,s, xlab="Location", ylab="Observation")
plot(x, s,
title = "Simple Kriging Example"
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example"
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example",
xlab="Location", ylab="Observation")
plot(x, s,
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
plot(s, x,
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
plot(s, x,
xlim=c(0,10), ylim=c(-3,3),
main="Simple Kriging Example",
xlab="Location", ylab="Observation",
pch=19)
dyn.load?
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okadaMatrix.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okada.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okadaMatrix.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okadaMatrix.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# add the negative log likelihood from the C++ code
compile("CSZmodel1.cpp")
dyn.load(dynlib("CSZmodel1"))
# which earthquake the model is run for
# Levels: T1 T10 T10R1 T11 T12 T2 T3 T3a T4 T4a T5 T5a T5b T6 T6a T7 T7a T8 T8a T9 T9a
# takes a while to make T1 okada matrix, can use T3 or T4 for quicker run times.
earthquake = "T1"
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR1.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as triGeomFull
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the okada matrix
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrix", earthquake, ".RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load(paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G = getOkada(geom = triGeomFull,
lon  = dr1$Lon[dr1$event == earthquake],
lat  = dr1$Lat[dr1$event == earthquake],
earthquake = earthquake)
}
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/Setup.R", echo=TRUE)
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# add the negative log likelihood from the C++ code
compile("CSZmodel1.cpp")
dyn.load(dynlib("CSZmodel1"))
# which earthquake the model is run for
# Levels: T1 T10 T10R1 T11 T12 T2 T3 T3a T4 T4a T5 T5a T5b T6 T6a T7 T7a T8 T8a T9 T9a
# takes a while to make T1 okada matrix, can use T3 or T4 for quicker run times.
earthquake = "T1"
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR1.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as triGeomFull
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the okada matrix
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrix", earthquake, ".RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load(paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G = getOkada(geom = triGeomFull,
lon  = dr1$Lon[dr1$event == earthquake],
lat  = dr1$Lat[dr1$event == earthquake],
earthquake = earthquake)
}
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMeshSimple.RData") # loads in triangular fault geometry as triGeomFault
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
## get the observed subsidence data for the correct earthquake
# Note change sign to minus since Okada model gives negative values for downwards movements.
subsidence = -dr1$subsidence[dr1$event == earthquake]
# I assume that these are the sigma values to be used?
sigma = dr1$Uncertainty[dr1$event == earthquake]
N = length(subsidence) # number of data points
K = length(triGeomFull) # number of subfaults
M = dim(inla_mesh$loc)[1] # number of points in spde mesh
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -triGeomFull[[i]]$depth / (10^3) # change to kms
}
## SPDE part: builds 3 components of Q (precision matrix)
# copied from lindgren example
spde = inla_spde$param.inla[c("M0","M1","M2")]
# set up the data list
data = list(depth      = depths,
subsidence = subsidence,
sigma      = sigma,
okada      = as.matrix(G),
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
spde       = spde)
# the parameters to optimise
# I am guessing ar good starting parameters
parameters = list(x          = rep(0, M),
log_lambda = log(1/10),
mu         = 3,
log_kappa  = 2.5,
log_tau    = -2.0)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/spde_mesh.R", echo=TRUE)
plotMesh(inla_mesh)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/baseMap.R", echo=TRUE)
plotMesh(inla_mesh)
plotSlab(triGeomFull)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/slab.R", echo=TRUE)
plotSlab(triGeomFull)
## create the objective function using TMB
# is random="x"?
# it was in the lindgren paper
# it doesn't work with random="x"
obj = MakeADFun(data, parameters, random="x", DLL="CSZmodel1", hessian=TRUE)
opt = optim(obj$par, obj$fn, obj$gr, method="BFGS") #, lower=L, upper=U)
opt
exp(opt$par)
obj$report
obj$par
rep = obj$report
rep = sdreport(obj)
rep$value
rep$par.fixed
rep$diag.cov.random
M
K
N
rep$env$parameters$x
rep$env$random
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# add the negative log likelihood from the C++ code
compile("CSZmodel1.cpp")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# add the negative log likelihood from the C++ code
compile("CSZmodel1.cpp")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# add the negative log likelihood from the C++ code
compile("CSZmodel1.cpp")
dyn.load(dynlib("CSZmodel1"))
# which earthquake the model is run for
# Levels: T1 T10 T10R1 T11 T12 T2 T3 T3a T4 T4a T5 T5a T5b T6 T6a T7 T7a T8 T8a T9 T9a
# takes a while to make T1 okada matrix, can use T3 or T4 for quicker run times.
earthquake = "T1"
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR1.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as triGeomFull
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the okada matrix
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/OkadaMatrix", earthquake, ".RData")
# should have already made Okada matrix for this earthquake
if (file.exists(dir)){
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada")
load(paste0("OkadaMatrix", earthquake, ".RData"))
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
} else {
# otherwise create the new okada unit vector
# The summation step is skipped, as this happens when G is matrix multiplied with the slip vector
G = getOkada(geom = triGeomFull,
lon  = dr1$Lon[dr1$event == earthquake],
lat  = dr1$Lat[dr1$event == earthquake],
earthquake = earthquake)
}
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMeshSimple.RData") # loads in triangular fault geometry as triGeomFault
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
## get the observed subsidence data for the correct earthquake
# Note change sign to minus since Okada model gives negative values for downwards movements.
subsidence = -dr1$subsidence[dr1$event == earthquake]
# I assume that these are the sigma values to be used?
sigma = dr1$Uncertainty[dr1$event == earthquake]
N = length(subsidence) # number of data points
K = length(triGeomFull) # number of subfaults
M = dim(inla_mesh$loc)[1] # number of points in spde mesh
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -triGeomFull[[i]]$depth / (10^3) # change to kms
}
## SPDE part: builds 3 components of Q (precision matrix)
# copied from lindgren example
spde = inla_spde$param.inla[c("M0","M1","M2")]
# set up the data list
data = list(depth      = depths,
subsidence = subsidence,
sigma      = sigma,
okada      = as.matrix(G),
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
spde       = spde)
# the parameters to optimise
# I am guessing ar good starting parameters
parameters = list(x          = rep(0, M),
log_lambda = log(1/10),
mu         = 3,
log_kappa  = 2.5,
log_tau    = -2.0)
## create the objective function using TMB
# is random="x"?
# it was in the lindgren paper
# it doesn't work with random="x"
obj = MakeADFun(data, parameters, random="x", DLL="CSZmodel1", hessian=TRUE)
opt = optim(obj$par, obj$fn, obj$gr, method="BFGS") #, lower=L, upper=U)
opt
lambda = exp(opt$par[1])
mu = opt$par[2]
kappa = exp(opt$par[3])
tau = exp(opt$par[4])
lambda
lambda[1]
lambda[[1]]
lambda = exp(opt$par[1])[[1]]
mu = opt$par[2][[1]]
kappa = exp(opt$par[3])[[1]]
tau = exp(opt$par[4])[[1]]
rep = report(obj)
rep = adreport(obj)
rep = obj$report()
rep$Q
type(rep$Q)
?rep$Q
rep = obj$report()
Q = as.matrix(rep$Q)
predictCSZ = function(lambda, mu, tau, kappa, Q, G, depths, sigma, idx){
N = dim(G)[1] # number of subsidence points
K = dim(G)[2] # number of subfaults
M = dim(Q)[1] # number of basis function
sigma = (1/tau)*solve(Q) # probably a better way to do this
x = rmvnorm(M, mean=rep(0, M), sigma=sigma)
t = exp(-lambda * depths)
s = t * exp(mu + x[idx])
eps = rep(0, N)
for (i in 1:N){
eps[i] = rnorm(N, mean=0, sd=sigma[i])
}
okadaSub = G %*% s # do I need to add the error on here?
print(okadaSub)
}
predictCSZ(labda, mu, tau, kappa, Q, as.matrix(G), depths, sigma, inla_mesh$idx$loc)
predictCSZ(lambda, mu, tau, kappa, Q, as.matrix(G), depths, sigma, inla_mesh$idx$loc)
predictCSZ = function(lambda, mu, tau, kappa, Q, G, depths, sigma, idx){
N = dim(G)[1] # number of subsidence points
K = dim(G)[2] # number of subfaults
M = dim(Q)[1] # number of basis function
sigma = (1/tau)*solve(Q) # probably a better way to do this
x = rmvnorm(M, mean=rep(0, M), sigma=sigma)
t = exp(-lambda * depths)
s = t * exp(mu + x[idx])
eps = rep(0, N)
for (i in 1:N){
eps[i] = rnorm(1, mean=0, sd=sigma[i])
}
okadaSub = G %*% s # do I need to add the error on here?
print(okadaSub)
}
predictCSZ(lambda, mu, tau, kappa, Q, as.matrix(G), depths, sigma, inla_mesh$idx$loc)
M
N
K
opt
rho = sqrt(8.0*1)/exp(opt$par[3])
rho
t = exp(-exp(opt$par[1]) * seq(0, 30, l=100))
plot(t)
plot(seq(0, 30, l=100), t)
