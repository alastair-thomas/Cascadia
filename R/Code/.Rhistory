compile("MultiQuakeCSZ.cpp")
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
dyn.load(dynlib("MultiQuakeCSZ"))
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okadaMatrix.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okada.R", echo=TRUE)
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/utilityFuns.R", echo=TRUE)
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR3.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFullFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as "mediumFault"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
G.append(matrix(0, nrow=5, ncol=5))
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquake[i]]
thisLon = DR3$Lat[DR3$event == earthquake[i]]
thisSub = DR3$subsidence[DR3$event == earthquake[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquake[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLon = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
simpleFault
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
#thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
print(thisLon)
print(thisLat)
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
print(length(thisLon))
print(length(thisLat))
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
?norm
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okada.R", echo=TRUE)
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/okada.R", echo=TRUE)
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i))
G[[i]] = thisG
subsidences[[i]] = thisSub
v[[i]] = thisUnc
}
dim(G[[2]])
length(subsidences[[2]])
G[[2]]
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMesh.RData") # loads in two spde objects
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
for (i in 1:length(subsidences)){
subsidences[[i]] = -subsidences[[i]]
}
K = length(simpleFault) # number of subfaults
M = dim(inla_mesh$loc)[1] # number of points in spde mesh
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -simpleFault[[i]]$depth / (10^3) # change to kms
}
## SPDE part:
# Create the spde object with correct priors
# PC priors on SPDE
# P(range < a) = b
# P(sigma > c) = d
a = 200 # Estimated range of the spatial field
b = 0.5
c = 1 # an ``upper bound'' on the variance
d = 0.05
maternPri = c(a, b, c, d)
# create spde object
inla_spde = inla.spde2.pcmatern(inla_mesh,
alpha=2,
prior.range=c(a, b),
prior.sigma=c(c, d))
source("~/Uni/NTNU/Masters Project/CSZ/R/Code/Setup.R", echo=TRUE)
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i, ".RData")
if (file.exists(dir)){
load(dir)
} else{
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=dir)
}
G[[i]] = thisG
subsidences[[i]] = -thisSub # remember the change of sign
v[[i]] = thisUnc
}
# Make the Okada matrix for every earthquake
G = list() # the list of matrices
subsidences = list() # list of subsidence vectors
v = list()
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
for (i in 1:length(earthquakes)){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i, ".RData")
if (file.exists(dir)){
load(dir)
} else{
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=dir)
}
G[[i]] = as.matrix(thisG)
subsidences[[i]] = -thisSub # remember the change of sign
v[[i]] = thisUnc
}
M = length(earthquakes)
K = length(simpleFault) # number of subfaults
inla_mesh
length(inla_mesh)
inla_mesh$loc
dim(inla_mesh$loc)
dim(inla_mesh$loc)[1]
inla_mesh
B = dim(inla_mesh$loc)[1] # number of basis functions
plogis(0)
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# Building the CSZ model using TMB
library(TMB)
# Add the negative log likelihood functions from the TMB code
compile("MultiQuakeCSZ.cpp")
dyn.load(dynlib("MultiQuakeCSZ"))
# load in the subsidence data
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Subsidence")
load("DR3.RData")
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
# load in the fault geometry
# if not saved run the function "getFullFaultGeometry"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/Fault Geometry")
load("simpleFault.RData") # loads in triangular fault geometry as "mediumFault"
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
K = length(simpleFault) # number of subfaults
# Creat the correct data for each earthquake
G = list() # the list of Okada matrices
subsidences = list() # list of subsidence vectors
v = list() # list of uncertainties
earthquakes = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T11","T12")
M = length(earthquakes) # number of earthquakes
for (i in 1:M){
thisLon = DR3$Lon[DR3$event == earthquakes[i]]
thisLat = DR3$Lat[DR3$event == earthquakes[i]]
thisSub = DR3$subsidence[DR3$event == earthquakes[i]]
thisUnc = DR3$Uncertainty[DR3$event == earthquakes[i]]
dir = paste0("~/Uni/NTNU/Masters Project/CSZ/R/Data/Okada/Simple MultiQuake/G", i, ".RData")
if (file.exists(dir)){
load(dir)
} else{
thisG = getOkada(simpleFault, thisLon, thisLat)
save(thisG, file=dir)
}
G[[i]] = as.matrix(thisG)
subsidences[[i]] = -thisSub # remember the change of sign
v[[i]] = thisUnc
}
# load in the spde mesh and spde structure
# created based on the fault geometry
# if not saved then run "spde_mesh.R" to create the files
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Data/SPDE")
load("spdeMesh.RData") # loads in two spde objects
setwd("~/Uni/NTNU/Masters Project/CSZ/R/Code")
B = dim(inla_mesh$loc)[1] # number of basis functions
## extract the depths of the centers of each subfault
depths = rep(0, K) # empty vector for depths
for (i in 1:K){
# Use positive depths
# as depth increases, taper goes from one to zero
depths[i] = -simpleFault[[i]]$depth / (10^3) # change to kms
}
## SPDE part:
# Create the spde object with correct priors
# PC priors on SPDE
# P(range < a) = b
# P(sigma > c) = d
a = 200 # Estimated range of the spatial field
b = 0.5
c = 1 # an ``upper bound'' on the variance
d = 0.05
maternPri = c(a, b, c, d)
# create spde object
inla_spde = inla.spde2.pcmatern(inla_mesh,
alpha=2,
prior.range=c(a, b),
prior.sigma=c(c, d))
# get the matricies out
spdeMatrix = inla_spde$param.inla[c("M0","M1","M2")]
# shape found from taperPrior.R
# means that 95% of the time the taper drops to 0.05 by 20km.
shape = 93.757027137
scale = 0.001316695
taperPri = c(shape, scale)
# set up the data list
data = list(depth      = depths,
subsidence = subsidences,
v          = v,
okada      = G,
spde_idx   = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
M0         = spdeMatrix$M0,
M1         = spdeMatrix$M1,
M2         = spdeMatrix$M2,
maternPri  = maternPri,
taperPri   = taperPri)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = matrix(0, ncols=M, ncols=B),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = matrix(0, ncols=M, nrows=B),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
M
B
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = matrix(0, nrow=B, ncol=M),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="BayesianCSZ",
hessian=TRUE)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="MultiQuakeCSZ",
hessian=TRUE)
# set up the data list
data = list(depth      = depths,
subsidence = subsidences,
v          = v,
okada      = G,
spdeIDX    = inla_mesh$idx$loc - 1, # -1 because c++ starts array indexes at 0.
M0         = spdeMatrix$M0,
M1         = spdeMatrix$M1,
M2         = spdeMatrix$M2,
maternPri  = maternPri,
taperPri   = taperPri)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(x          = matrix(0, nrow=B, ncol=M),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="MultiQuakeCSZ",
hessian=TRUE)
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(X          = matrix(0, nrow=B, ncol=M),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="x",
DLL="MultiQuakeCSZ",
hessian=TRUE)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="X",
DLL="MultiQuakeCSZ",
hessian=TRUE)
## Optimize the model parameters
opt0 = nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr)
opt0
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 1000))[3]
opt0
optTime
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 10000))[3]
opt0
# the parameters to optimise
# I am guessing are good starting parameters
parameters = list(X          = matrix(0.5, nrow=B, ncol=M),
w          = rep(0, B),
logitPhi   = 0,
logLambda  = -2.1,
mu         = 3.6,
logKappa   = -4.4,
logTau     = 3.7)
## create the objective function using TMB
obj = MakeADFun(data,
parameters,
random="X",
DLL="MultiQuakeCSZ",
hessian=TRUE)
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 10000))[3]
opt0
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 100000))[3]
opt0
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 10000,
eval.max  = 10000))[3]
opt0
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
iter.max  = 100000,
eval.max  = 100000))[3]
opt0
?nlminb
## Optimize the model parameters
optTime = system.time(opt0 <- nlminb(start     = obj$par,
objective = obj$fn,
gradient  = obj$gr,
control   = list(iter.max  = 100000,
eval.max  = 100000)))[3]
