## Using multiple compilation units with TMB

Compilation time may be an issue when working with bigger projects in
TMB because the entire project needs re-compilation whenever the TMB
model code is changed. To address this problem one can split a TMB
project into several compilation units that can be updated
individually without re-compiling other units.

We will use
[tmb_examples/adaptive_integration.cpp](../../tmb_examples/adaptive_integration.cpp)
as example because it takes fairly long time to compile. We split the
file into three new units:

| Compilation unit          | Description                                             |
|---------------------------|---------------------------------------------------------|
|`adaptive_integration.cpp` | Objective function (the main file)                      |
|`distrib.cpp`              | Special function using adaptive integration             |
|`TMB.cpp`                  | TMB core functions (AD library and R interfacing code)  |

In addition we need header files `distrib.h` and `TMB.h` to include in
the main file. Note that the `*.h` extension is required for C++
headers in R packages.

### Generating the files

The main file [adaptive_integration.cpp](./adaptive_integration.cpp)
is created by copy-pasting the objective function and adding the two
header includes `TMB.h` and `distrib.h`.

The Files `TMB.cpp` and `TMB.h` are autogenerated by running from R
`TMB::precompile(get.header=TRUE, all=FALSE)`, or even better by
putting the command in a [Makevars](Makevars) file.  As a side note,
one can pass `all=TRUE` in order to precompile a bigger portion of
TMB. This is currently only relevant for projects using the namespace
'density'.

The files [distrib.cpp](./distrib.cpp) and [distrib.h](./distrib.h)
are a bit more tricky. The special function namespace `my_atomic` is
copy-pasted to `distrib.h`. In addition a switch `DISTRIB_PRECOMPILE`
is added *after* including `TMB.h`. The switch implicitly controls the
expansion of the TMB code generation macros (in this case
`TMB_BIND_ATOMIC`).  Finally, `distrib.cpp` sets the precompile switch
and includes the header.

### Prepare the setup

The approach described here is especially relevant for R packages
linking to TMB.  When compiling R packages, no TMB specific
preprocessor flags are set by default. To mimic this behaviour, we
start by overloading the TMB compile function accordingly:

```{r}
compile <- function(file) TMB::compile(file, safebounds=FALSE, safeunload=FALSE, libtmb=FALSE, libinit=FALSE)
```

### Testing compilation

For comparison it may be useful to test the compilation time of the
original (unsplit) model code:

```r
system.time(compile("../../tmb_examples/adaptive_integration.cpp"))
```

We skip this step here, and instead turn to compiling the project. The
project consists of the files

```{r}
project <- c("adaptive_integration.cpp", "distrib.cpp", "TMB.cpp")
```

First compilation takes a while...

```{r}
system.time(compile(project))
```

When working with the project it is expected that
`adaptive_integration.cpp` is updated frequently, `distrib.cpp` is
updated rarely while `TMB.cpp` is never updated. Let's update the main
file (or remove the corresponding object file) and recompile:

```{r}
file.remove("adaptive_integration.o")
system.time(compile(project))
```

This should be much faster than compiling the single file project from
scratch.

### Testing that the compiled code works

We can now run the model:

```{r}
source("../../tmb_examples/adaptive_integration.R",echo=TRUE)
```

### Linker issues

A common mistake when splitting *header only* source code in several
units is to define a helper function in more than one unit. This
results in the 'multiple definition' linker error. For example,
placing a function

```cpp
double foo(double x) { return x; }
```

inside the 'my_atomic' namespace of `distrib.h` will cause the
error. Depending on the context, the following simple solutions are
available:

1. Place the `inline` keyword in front of the function:
   `inline double foo(double x) { return x; }`
2. Put the function in an anonymous namespace:
   `namespace { double foo(double x) { return x; } }`
3. Turn `foo()` into a template function by adding a dummy template
   argument (available from C++11):
   `template<class dummy=void> double foo(double x) { return x; }`
4. Wrap the TMB macro `CSKIP` around the body of the function:
   `double foo(double x) CSKIP ({ return x; })`

Option 1 or 2 can be used if the function `foo()` is only to be
applied *locally* inside `distrib.h` or `distrib.cpp`.

Option 3 or 4 can be used if `foo()` is to be used by other units as
well. Note that (4) compiles the function once, while (3) compiles a
new version of the function for each compilation unit that uses it.
